import { ImportStatementParams, ParsedField } from './types';
export declare const scalarToTS: (scalar: string, useInputTypes?: boolean) => string;
export declare const echo: (input: string) => string;
export declare const when: (condition: any, thenTemplate: string, elseTemplate?: string) => string;
export declare const unless: (condition: any, thenTemplate: string, elseTemplate?: string) => string;
export declare const each: <T = any>(arr: T[], fn: (item: T) => string, joinWith?: string) => string;
export declare const importStatement: (input: ImportStatementParams) => string;
export declare const importStatements: (items: ImportStatementParams[]) => string;
interface MakeHelpersParam {
    connectDtoPrefix: string;
    createDtoPrefix: string;
    updateDtoPrefix: string;
    dtoSuffix: string;
    entityPrefix: string;
    entitySuffix: string;
    transformClassNameCase?: (item: string) => string;
    transformFileNameCase?: (item: string) => string;
    classValidation: boolean;
    outputType: string;
    noDependencies: boolean;
    definiteAssignmentAssertion: boolean;
    requiredResponseApiProperty: boolean;
    outputPath: string;
    prismaClientImportPath: string;
    outputApiPropertyType: boolean;
    wrapRelationsAsType: boolean;
    showDefaultValues: boolean;
}
export declare const makeHelpers: ({ connectDtoPrefix, createDtoPrefix, updateDtoPrefix, dtoSuffix, entityPrefix, entitySuffix, transformClassNameCase, transformFileNameCase, classValidation, outputType, noDependencies, definiteAssignmentAssertion, requiredResponseApiProperty, outputPath, prismaClientImportPath, outputApiPropertyType, wrapRelationsAsType, showDefaultValues, }: MakeHelpersParam) => {
    config: {
        connectDtoPrefix: string;
        createDtoPrefix: string;
        updateDtoPrefix: string;
        dtoSuffix: string;
        entityPrefix: string;
        entitySuffix: string;
        classValidation: boolean;
        outputType: string;
        noDependencies: boolean;
        definiteAssignmentAssertion: boolean;
        requiredResponseApiProperty: boolean;
        outputPath: string;
        prismaClientImportPath: string;
        outputApiPropertyType: boolean;
        wrapRelationsAsType: boolean;
        showDefaultValues: boolean;
    };
    apiExtraModels: (names: string[]) => string;
    entityName: (name: string) => string;
    connectDtoName: (name: string) => string;
    createDtoName: (name: string) => string;
    updateDtoName: (name: string) => string;
    plainDtoName: (name: string) => string;
    connectDtoFilename: (name: string, withExtension?: boolean) => string;
    createDtoFilename: (name: string, withExtension?: boolean) => string;
    updateDtoFilename: (name: string, withExtension?: boolean) => string;
    entityFilename: (name: string, withExtension?: boolean) => string;
    plainDtoFilename: (name: string, withExtension?: boolean) => string;
    each: <T = any>(arr: T[], fn: (item: T) => string, joinWith?: string) => string;
    echo: (input: string) => string;
    fieldsToDtoProps: (fields: ParsedField[], dtoType: 'create' | 'update' | 'plain', useInputTypes?: boolean, forceOptional?: boolean) => string;
    fieldToDtoProp: (field: ParsedField, dtoType: 'create' | 'update' | 'plain', useInputTypes?: boolean, forceOptional?: boolean) => string;
    fieldToEntityProp: (field: ParsedField) => string;
    fieldsToEntityProps: (fields: ParsedField[]) => string;
    fieldType: (field: ParsedField, dtoType?: 'create' | 'update' | 'plain', toInputType?: boolean) => string;
    for: <T = any>(arr: T[], fn: (item: T) => string, joinWith?: string) => string;
    if: (condition: any, thenTemplate: string, elseTemplate?: string) => string;
    importStatement: (input: ImportStatementParams) => string;
    importStatements: (items: ImportStatementParams[]) => string;
    transformClassNameCase: (item: string) => string;
    transformFileNameCase: (item: string) => string;
    unless: (condition: any, thenTemplate: string, elseTemplate?: string) => string;
    when: (condition: any, thenTemplate: string, elseTemplate?: string) => string;
};
export type TemplateHelpers = ReturnType<typeof makeHelpers>;
export {};
